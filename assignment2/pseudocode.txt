----------------
State : Follower
----------------

on VoteReq(from, term, candidateId, lastLogIndex, lastLogTerm)
	if sm.currentTerm <= msg.term &&
		sm.votedFor == nil or sm.votedFor  == msg.candidateId,
			if candidate log is at least as up-to-date as receiver's log, 
				sm.currentTerm = msg.term
				sm.votedFor = msg.candidateId
				action = Send(msg.from, VoteResp(sm.term, voteGranted =no))
	Otherwise, reject vote:
		action = Send(msg.from, VoteResp(sm.term, voteGranted =no))
	Alarm(sm.ElectionTimeout)


on Append(data:[]byte)
		Send(leaderId, Append(data))

on Timeout
		change State = Follower
		Alarm(0)

on AppendEntriesReq(term, leaderId, prevLogIndex, prevLogTerm, entries[], leaderCommit):
		if msg.term > sm.currentTerm
			sm.currentTerm = msg.term 
			sm.leaderId = msg.leaderId

		if  sm.currentTerm > msg.term
   			 action = Send(msg.leaderId, AppendEntriesResp(sm.currentTerm, null , success =no))
		 else if  (sm.log[msg.prevLogIndex].term != msg.prevLogTerm) 
   	 		action = Send(msg.leaderId, AppendEntriesResp(sm.currentTerm, null, success =no))
		else
			 if  sm.lastLogIndex > msg.prevLogIndex
		   		 sm.lastLogIndex = msg.prevLogIndex
		   	 LogStore(sm.lastLogIndex + 1, entries)    
		   	 sm.lastLogIndex += entries.size()
		   	 sm.lastLogTerm = sm.CurrentTerm
		   	 action = Send(msg.leaderID, AppendEntriesResp(sm.currentTerm, sm.lastLogIndex, success =yes))
	   		 if sm.commitIndex < msg.leaderCommit   
		   		 commitIndex = min(leaderCommit, sm.lastLogIndex)
		   		 Commit(index, data, err)
			Alarm(sm.ElectionTimeout)


on AppendEntriesResp(term, success):
	if msg.term > sm.currentTerm
		sm.currentTerm = msg.term 


on VoteResp(term , voteGranted):
	if msg.term > sm.currentTerm
		sm.currentTerm = msg.term 


-----------------
State : Candidate
-----------------

on VoteReq(from, term, candidateId, lastLogIndex, lastLogTerm) 
	if sm.term < msg.term
	   	 State = Follower
	   	 sm.currentTerm = msg.term
	   	 sm.votedFor = msg.Id
	   	 action = Send(msg.from, VoteResp(sm.term, voteGranted =yes))
	   	 Alarm(sm.ElectionTimeout)
	 else    
	   	 action = Send(msg.from, VoteResp(sm.term, voteGranted =no))
	    

on Append(data:[]byte)
	//Drop
	Send fail

on Timeout
	sm.currentTerm++
	sm.votedFor[sm.currentTerm] = sm.Id
	sm.votesRecieved = 1
	for (i=0; i<sm.numPeers; i++){
		if (i != sm.Id)
   		 Send(i, VoteReq(sm.Id, sm.term, sm.Id, sm.lastLogIndex, sm.lastLogTerm))
	}
	Alarm(random_number from [T,2T])


on AppendEntriesReq(term, leaderId, prevLogIndex, prevLogTerm, entries[], leaderCommit):
	if msg.term >= sm.currentTerm
		sm.currentTerm = msg.term 
		State = Follower
		Alarm(sm.ElectionTimeout[T,2T])


	if  sm.currentTerm > msg.term
			 action = Send(msg.leaderId, AppendEntriesResp(sm.currentTerm, success =no))
	else if  (sm.log[msg.prevLogIndex].term != msg.prevLogTerm)    
	 		action = Send(msg.leaderId, AppendEntriesResp(sm.currentTerm, success =no))
	else
		 if  sm.lastLogIndex > msg.prevLogIndex
		   		 sm.lastLogIndex = msg.prevLogIndex
		   	 LogStore(sm.lastLogIndex + 1, entries)    
		   	 sm.lastLogIndex += entries.size()
		   	 sm.lastLogTerm = sm.CurrentTerm
		   	 action = Send(msg.leaderID, AppendEntriesResp(sm.currentTerm, sm.lastLogIndex, success =yes))
	   		 if sm.commitIndex < msg.leaderCommit   
		   		 commitIndex = min(leaderCommit, sm.lastLogIndex)
		   		 Commit(index, data, err)

    Alarm(sm.ElectionTimeout[T,2T])


on AppendEntriesResp(term, success):
	//Drop

on VoteResp(term , voteGranted):
	if sm.currentTerm == msg.term && voteGranted == true
   	 sm.votesRecieved ++ 
  	
	if sm.votesRecieved > sm.numPeers/2    
		State = Leader
		nextIndex[], matchIndex[] //reset both
	 	for (i=0; i<sm.numPeers; i++)
		 if (i != sm.Id)
			 nextIndex[i] = sm.lastLogIndex + 1
			 matchIndex[i] = 0
			 send(i, AppendEntriesReq(sm.Id, sm.currentTerm, sm.lastLogIndex, sm.lastLogTerm, [], sm.commitIndex))




--------------
State : Leader
--------------

on VoteReq(from, term, candidateId, lastLogIndex, lastLogTerm)
  if msg.term > sm.currentTerm
      sm.currentTerm = msg.term
      change State = Follower
      votedFor = msg.Id
      Send(msg.from, VoteResp(sm.currentTerm, voteGranted =yes))
    else     
     action = Send(msg.from, VoteResp(sm.currentTerm, voteGranted =no))

on Append(data:[]byte)
	LogStore(sm.lastLogIndex + 1, data []byte)
	for (i=0; i<sm.numPeers; i++) //to be done in parallel
	     if (i != sm.Id)
	   	   send(i, AppendEntriesReq(sm.Id, sm.term, sm.lastLogIndex, sm.lastLogTerm, byte, sm.commitIndex))
	       nextIndex[i] = sm.lastLogIndex + 1
	       matchIndex[i] = 0   
	sm.lastLogIndex ++  
	sm.lastLogTerm = sm.currentTerm
	Alarm(heartBeatTimeOut)


on Timeout
	for (i=0; i<sm.numPeers; i++)
     if (i != sm.Id)
       nextIndex[i] = sm.lastLogIndex + 1
       matchIndex[i] = 0
       send(i, AppendEntriesReq(sm.Id, sm.term, sm.lastLogIndex, sm.lastLogTerm, [], sm.commitIndex))
	Alarm(heartBeatTimeOut)

on AppendEntriesReq(term, leaderId, prevLogIndex, prevLogTerm, entries[], leaderCommit):
	if msg.term > sm.currentTerm
      sm.currentTerm = msg.term
      State = Follower
      Alarm(sm.ElectionTimeout)

on AppendEntriesResp(term, index , success):
	if success: 
		matchIndex[msg.from] =  max ( matchIndex[msg.from], index) 
		nextIndex[msg.from] = index + 1
		if sm.lastLogIndex >= nextIndex[msg.from]
			send(i, AppendEntriesReq(sm.Id, sm.currentTerm, nextIndex[msg.from], sm.lastLogTerm, log[nextIndex[msg.from]:sm.lastLogIndex], sm.commitIndex))
		cnt =0
		for(i =0; i< sm.numPeers; i++){
			if (i != sm.Id && matchIndex[i] > leaderCommit ){
				cnt++
			}
		}
		if cnt > sm.numPeers/2 // Log entry at index "index" is stored on majority of server
			leaderCommit++
			Commit(index, data, err)
					
	else: //AppendEntries fails because of log inconsistency:
		nextIndex[msg.from]--
		send(i, AppendEntriesReq(sm.Id, sm.currentTerm, nextIndex[msg.from], sm.lastLogTerm, log[nextIndex[msg.from]:sm.lastLogIndex], sm.commitIndex))
	Alarm(heartBeatTimeOut)

on VoteResp(term , voteGranted):
	if msg.term > sm.currentTerm
		sm.currentTerm = msg.term 
		state = Follower
		Alarm(sm.ElectionTimeout)

